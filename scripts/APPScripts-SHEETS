/**
 * @OnlyCurrentDoc
 * Mail Merge Otimizado ‚Äì Suporte a m√∫ltiplos emails por c√©lula e controle estrito de lote.
 */

/** ===================== CONFIG ===================== **/
const RECIPIENT_COL    = "Email";
const EMAIL_SENT_COL   = "Email Sent";
const DRAFT_SUBJECT    = "Por que alguns an√∫ncios imobili√°rios performam mais";

// Configura√ß√µes de Lote
const BATCH_SIZE       = 95;   // Limite exato de envios por execu√ß√£o
const INTERVAL_MINUTES = 1450; // Intervalo at√© a pr√≥xima execu√ß√£o (~24h)
const TIMEZONE         = 'America/Sao_Paulo';
const SENDER_NAME      = 'Ibrand Agency';

/** ===================== MENU ===================== **/
function onOpen() {
  const ui = SpreadsheetApp.getUi();
  ui.createMenu('üìß Automa√ß√£o Pro')
    .addItem('üöÄ Iniciar Automa√ß√£o', 'startAutomation')
    .addItem('üõë Pausar Automa√ß√£o', 'stopAutomation')
    .addItem('üìä Status Detalhado', 'showStatus')
    .addToUi();
}

/** ===================== CONTROLE ===================== **/
function startAutomation() {
  try {
    // Limpa triggers antigos para evitar duplicidade
    stopAutomation(true); 

    const props = PropertiesService.getScriptProperties();
    props.setProperties({
      'AUTO_ACTIVE': 'true',
      'TOTAL_SENT': '0',
      'INTERVAL_MINUTES': String(INTERVAL_MINUTES),
      'BATCH_SIZE': String(BATCH_SIZE),
      'NEXT_RUN': '',
      'LAST_EXECUTION': ''
    });

    // Executa o primeiro lote
    runAutomation_();
    SpreadsheetApp.getUi().alert('Automa√ß√£o iniciada com sucesso.');
  } catch (err) {
    SpreadsheetApp.getUi().alert('Erro ao iniciar: ' + err.message);
  }
}

function stopAutomation(silent = false) {
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
  const props = PropertiesService.getScriptProperties();
  props.setProperty('AUTO_ACTIVE', 'false');

  if (!silent) {
    const total = props.getProperty('TOTAL_SENT') || '0';
    SpreadsheetApp.getUi().alert(`Automa√ß√£o pausada.\nTotal enviado nesta sess√£o: ${total}`);
  }
}

function showStatus() {
  const p = PropertiesService.getScriptProperties();
  const isActive = p.getProperty('AUTO_ACTIVE') === 'true';
  const total = p.getProperty('TOTAL_SENT') || '0';
  const last = p.getProperty('LAST_EXECUTION');
  const next = p.getProperty('NEXT_RUN');

  const ui = SpreadsheetApp.getUi();
  ui.alert(
    `STATUS DA AUTOMA√á√ÉO\n` +
    `-------------------\n` +
    `Estado: ${isActive ? 'üü¢ RODANDO' : 'üî¥ PARADO'}\n` +
    `Enviados (sess√£o atual): ${total}\n` +
    `√öltimo envio: ${last ? Utilities.formatDate(new Date(last), TIMEZONE, 'dd/MM HH:mm') : '‚Äî'}\n` +
    `Pr√≥xima execu√ß√£o: ${next ? Utilities.formatDate(new Date(next), TIMEZONE, 'dd/MM HH:mm') : '‚Äî'}`
  );
}

/** ===================== CORE AUTOMATION ===================== **/
function runAutomation_() {
  const lock = LockService.getScriptLock();
  // Tenta bloquear por 30s para evitar execu√ß√µes simult√¢neas
  if (!lock.tryLock(30000)) return;

  const props = PropertiesService.getScriptProperties();
  
  try {
    if (props.getProperty('AUTO_ACTIVE') !== 'true') return;

    const limit = Number(props.getProperty('BATCH_SIZE'));
    
    // === EXECUTA O ENVIO DO LOTE ===
    const result = processBatch_(limit);
    // ===============================

    // Atualiza contadores
    const currentTotal = Number(props.getProperty('TOTAL_SENT') || '0');
    const newTotal = currentTotal + result.sentCount;
    
    props.setProperty('TOTAL_SENT', String(newTotal));
    props.setProperty('LAST_EXECUTION', new Date().toISOString());

    // L√≥gica de agendamento
    if (result.hasMore) {
      // Se ainda tem gente na lista (hasMore = true), agenda o pr√≥ximo
      const nextRun = new Date(Date.now() + (Number(props.getProperty('INTERVAL_MINUTES')) * 60 * 1000));
      scheduleTrigger_('runAutomation_', nextRun);
      props.setProperty('NEXT_RUN', nextRun.toISOString());

      logEmail_(`Relat√≥rio de Lote (${result.sentCount} enviados)`, 
        `Lote finalizado.\nEnviados agora: ${result.sentCount}\nTotal acumulado: ${newTotal}\nPr√≥ximo envio: ${nextRun}`);
    } else {
      // Se acabou a lista
      stopAutomation(true); 
      props.deleteProperty('NEXT_RUN');
      logEmail_('Automa√ß√£o Finalizada', `Todos os e-mails da planilha foram processados.\nTotal enviado: ${newTotal}`);
    }

  } catch (error) {
    console.error(error);
    stopAutomation(true); // Pausa em caso de erro cr√≠tico
    logEmail_('ERRO CR√çTICO - Automa√ß√£o Pausada', `Erro: ${error.message}\nStack: ${error.stack}`);
  } finally {
    lock.releaseLock();
  }
}

/** * Processa a planilha linha a linha, e e-mail a e-mail dentro da c√©lula.
 * Retorna { sentCount: number, hasMore: boolean }
 */
function processBatch_(batchLimit) {
  const sheet = SpreadsheetApp.getActiveSheet();
  // Pega todos os dados como String para preservar formata√ß√£o
  const range = sheet.getDataRange();
  const data = range.getDisplayValues();
  const headers = data.shift(); // Remove cabe√ßalho

  const recipientIdx = headers.indexOf(RECIPIENT_COL);
  const statusIdx = headers.indexOf(EMAIL_SENT_COL);

  if (recipientIdx === -1 || statusIdx === -1) {
    throw new Error(`Colunas n√£o encontradas: "${RECIPIENT_COL}" ou "${EMAIL_SENT_COL}"`);
  }

  // Carrega o rascunho apenas uma vez
  const template = getGmailTemplate_(DRAFT_SUBJECT);
  
  let sentInThisBatch = 0;
  let hasMoreRecipients = false;

  // Loop pelas linhas
  for (let r = 0; r < data.length; r++) {
    const row = data[r];
    const rawEmails = row[recipientIdx];
    const currentStatus = row[statusIdx]; // O que j√° foi escrito na coluna de status

    // Se n√£o tem email, pula
    if (!rawEmails) continue;

    // 1. Extrai lista limpa de e-mails da c√©lula (separa por quebra de linha, v√≠rgula ou ponto e v√≠rgula)
    const targets = rawEmails.split(/[\n\r,;]+/)
                             .map(e => e.trim())
                             .filter(e => e !== '' && e.includes('@'));

    // 2. Verifica quais j√° foram enviados olhando a coluna de Status
    // A coluna status agora vai armazenar: "email1@teste.com (Data), email2@teste.com (Data)"
    const alreadySentList = currentStatus ? currentStatus.toLowerCase() : "";
    
    // Filtra apenas os pendentes
    const pending = targets.filter(email => !alreadySentList.includes(email.toLowerCase()));

    if (pending.length === 0) {
      continue; // Linha totalmente processada
    }

    // Se chegamos aqui, tem e-mail pendente nesta linha.
    // Agora processamos os pendentes AT√â bater o limite do lote.
    
    let emailsSentForThisRow = [];
    let rowError = null;

    for (const email of pending) {
      // CHECK DE LIMITE
      if (sentInThisBatch >= batchLimit) {
        hasMoreRecipients = true;
        break; // Sai do loop de emails, mas vai cair no return l√° embaixo
      }

      try {
        // Prepara mensagem personalizada
        const msg = fillTemplate_(template.message, row, headers);
        
        GmailApp.sendEmail(email, msg.subject, msg.text, {
          htmlBody: msg.html,
          name: SENDER_NAME,
          attachments: template.attachments,
          inlineImages: template.inlineImages
        });

        // Adiciona ao log tempor√°rio da linha
        const timestamp = Utilities.formatDate(new Date(), TIMEZONE, "dd/MM HH:mm");
        emailsSentForThisRow.push(`${email} (${timestamp})`);
        
        sentInThisBatch++;
        
        // Pausa anti-spam do Google (importante)
        Utilities.sleep(800); 

      } catch (e) {
        rowError = `Erro em ${email}: ${e.message}`;
        console.error(rowError);
      }
    }

    // === ATUALIZA A PLANILHA ===
    // S√≥ escreve na planilha se enviamos algo ou deu erro
    if (emailsSentForThisRow.length > 0 || rowError) {
      const existingText = currentStatus ? currentStatus + "\n" : "";
      const newLogText = existingText + emailsSentForThisRow.join("\n") + (rowError ? "\n" + rowError : "");
      
      // Atualiza a c√©lula exata (r + 2 pois r come√ßa em 0 e header ocupa 1)
      sheet.getRange(r + 2, statusIdx + 1).setValue(newLogText);
    }

    // Se paramos o loop interno porque bateu o limite, paramos o loop externo tamb√©m
    if (sentInThisBatch >= batchLimit) {
      // Verificamos se ainda sobraram e-mails nessa mesma linha ou nas pr√≥ximas
      if (pending.length > emailsSentForThisRow.length) hasMoreRecipients = true;
      // Precisamos checar se existem linhas ABAIXO desta que ainda t√™m pend√™ncias
      else if (checkIfMoreRowsExist_(data, r + 1, recipientIdx, statusIdx)) hasMoreRecipients = true;
      
      break; 
    }
  }

  // Verifica√ß√£o final se n√£o bateu o limite mas acabou o loop (para garantir que hasMore esteja certo)
  if (sentInThisBatch < batchLimit) {
    // Se processou tudo e n√£o bateu o limite, hasMore continua false, a menos que tenha sido setado antes
  }

  return { sentCount: sentInThisBatch, hasMore: hasMoreRecipients };
}

// Helper r√°pido para ver se tem mais gente nas linhas de baixo (otimiza√ß√£o)
function checkIfMoreRowsExist_(rows, startIndex, recIdx, statIdx) {
  for (let i = startIndex; i < rows.length; i++) {
    const raw = rows[i][recIdx];
    const stat = rows[i][statIdx];
    if (raw && (!stat || stat.length < raw.length)) return true; // L√≥gica simplificada
  }
  return false;
}

/** ===================== TEMPLATE ENGINE ===================== **/
function getGmailTemplate_(subject) {
  const draft = GmailApp.getDrafts().find(d => d.getMessage().getSubject() === subject);
  if (!draft) throw new Error(`Rascunho n√£o encontrado com assunto: "${subject}"`);

  const msg = draft.getMessage();
  const body = msg.getBody();
  
  // Tratamento de Imagens Inline
  const attachments = msg.getAttachments({includeInlineImages: false});
  const inlineAttachments = msg.getAttachments({includeInlineImages: true, includeAttachments: false});
  const inlineImages = {};
  
  if (inlineAttachments.length > 0) {
    const byName = {};
    inlineAttachments.forEach(a => byName[a.getName()] = a);
    
    // Regex para achar CIDs
    const regex = /src="cid:(.*?)"/g;
    let match;
    while ((match = regex.exec(body)) !== null) {
      const cid = match[1];
      // Tenta achar imagem pelo nome ou ID, Gmail √© chato com isso
      const img = inlineAttachments.find(a => a.getName() === cid) || inlineAttachments[0]; 
      if (img) inlineImages[cid] = img;
    }
  }

  return { 
    message: { subject: subject, text: msg.getPlainBody(), html: body }, 
    attachments: attachments, 
    inlineImages: inlineImages 
  };
}

function fillTemplate_(templateObj, rowData, headers) {
  let html = templateObj.html;
  let text = templateObj.text;
  let subj = templateObj.subject;

  // Cria mapa de chave:valor da linha atual
  const map = {};
  headers.forEach((h, i) => map[h] = rowData[i]);

  // Fun√ß√£o de replace segura
  const replaceVars = (str) => {
    return str.replace(/{{(.*?)}}/g, (match, key) => {
      const cleanKey = key.trim();
      return map[cleanKey] != null ? map[cleanKey] : ""; 
    });
  };

  return {
    html: replaceVars(html),
    text: replaceVars(text),
    subject: replaceVars(subj)
  };
}

/** ===================== UTILIDADES ===================== **/
function scheduleTrigger_(funcName, dateObj) {
  ScriptApp.getProjectTriggers().forEach(t => ScriptApp.deleteTrigger(t));
  ScriptApp.newTrigger(funcName).timeBased().at(dateObj).create();
}

function logEmail_(subject, body) {
  try {
    GmailApp.sendEmail(Session.getActiveUser().getEmail(), `[Bot] ${subject}`, body);
  } catch (e) {
    console.warn("Falha ao enviar email de log: " + e.message);
  }
}
